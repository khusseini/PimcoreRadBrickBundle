# PimcoreRadBrickBundle
A RAD way to create Areabricks in Pimcore

## Purpose

Configure data and editables available in Pimcore Areabricks view and edit templates.

## Installation
```
composer require khusseini/pimcore-radbrick
```

## Usage

Simply enable the Bundle, test out this configuration in your `config.yml` and start creating templates.

```yaml
pimcore_rad_brick:
  areabricks:
    my_wysiwyg: 
      label: WYSIWYG // Label to use in admin UI
      icon:  ~ // Path to icon in admin UI
      open: ~ // Set the open html
      close: ~ // Set the close html
      use_edit: false // Use edit.html.twig
      class: ~ // Use an existing symfony service
      editables:
        wysiwyg_content:
          type: wysiwyg
          options: [] // you can pass here any options accepted by the editable
```

Now create a template as usual in `views/Areas/my_wysiwyg/view.html.twig`:
```twig
{# add autogenerated meta description #}
{% do pimcore_head_meta().setDescription(wysiwyg_content.getData(), 160) %}
<div class="content">
  {% pimcoreglossary %}
    {{ wysiwyg_content|raw }}
  {% endpimcoreglossary %}
</div>
```


### Creating multiple instances

In order to create multiple instances of an editable with the same configuraiton,
it is as easy as adding the `instances` attribute:

`config.yml`
```yml
pimcore_rad_brick:
  areabricks:
    my_wysiwyg: 
      label: WYSIWYG
      editables:
        wysiwyg_content:
          instances: 3
          instance_ids: ['one', 'two', 'three'] // you can specifically set the postfix of the instance name (which will result in the twig variable name)
          type: wysiwyg
          options: [] // you can pass here any options accepted by the editable
```

The instance variables are created using the basename of the editable and postfixing it with either the provided ids in `instance_ids` or by simply using the array index.

```twig
{% for wysiwyg_instance in wysiwyg_content %}
  {{ wysiwyg_instance|raw }}
{% endfor %}
```

or 
```twig
<div>
Come content:
{{ wysiwyg_content.one|raw }}
</div>
<div>
Other Content:
{{ wysiwyg_content.two|raw }}
</div>
<div>
More Content:
{{ wysiwyg_content.three|raw }}
</div>
```

#### Making instances configurable

In most cases, it doesn't make much sense to hardcode the number of instances
of an editable. In order to make the number of instances configurable via admin
we will leverage the power of the (Expression Language Component)[https://symfony.com/doc/current/components/expression_language.html].

```yml
pimcore_rad_brick:
  areabricks:
    my_wysiwyg: 
      label: WYSIWYG
      use_edit: true // Note that we use an edit template to configure the instances
      editables:
        num_editors:
          type: select
          options:
            store: [1,2,5]
        wysiwyg_content:
          instances: view[num_editors].getValue()
          type: wysiwyg
```

NOTE: The expression context contains the following objects:
- `request`: The current `Request` object
- `view`: The current `ViewModel`
- `datasources`: The `DatasourceRegistry`


#### Practical example

A more practical example is an integration into the bootstrap grid.
Two areabricks can be easily created in order to support the bootstrap grid.

```yaml
pimcore_rad_brick:
  areabricks:
    container:
      label: Container
      use_edit: true
      editables:
        container_css_class:
          type: input
        container_area_block:
          type: areablock
          options:
            allowed:
            - columns
            params:
              forceEditInView: true
    columns:
      label: Columns
      use_edit: true
      editables:
        num_columns:
          type: select
          options:
            store: [1, 2, 3, 4, 5, 6]
            defaultValue: 1
        column_area_block:
          instances: view[num_columns].getData()
          type: areablock
          options:
            params:
              forceEditInView: true
```

`container/view.html.twig`:
```twig
<div class="container">
  {{ container_area_block|raw }}
</div>
```

`columns/view.html.twig`:
```twig
{% set col_width = 12 / num_columns.getData() %}
<div class="row">
  {% for i in range(0, num_columns.getData()) %}
  <div class="col-{{ col_width }}">
      {{ column_area_block[i-1]|raw }}
  </div>
  {% endfor %}
</div>
```

### Using maps

At times an editable in your areabrick depends on some configuration value.
The `map` configuration node may be used to map data between editables.

For example an image areabrick may be configured to use a specific thumbnail:

`edit.html.twig`
```twig
Thumbnail: {{ image_thumbnail|raw }}
```

`view.html.twig`
```twig
<div class="image-container">
{{ image_content|raw }}
</div>
```

`config.yml`
```yml
pimcore_rad_brick:
  areabricks:
    image:
      label: Image
      editables:
        image_thumbnail:
          type: input
        image_content:
          type: image
          map: 
          - source: '[image_thumbnail].data'
            target: '[options][thumbnail]'
```

The `source` and `target` properties uses the [Symfony Property Access Component](https://symfony.com/doc/current/components/property_access.html) to fetch and insert data.

The above mapping example would fetch the `data` property's value from `image_thumbnail` editable (resides in ViewModel, hence the array notation) and insert right into the config tree in `[pimcore_rad_brick][areabricks][image][editables][image_content][options][thumbnail]`

### Using Datasources

Datasources simplify the creation of widgets that get their data from other services. For example, in CoreShop one might want to show a slider that contains the products of a certain category.

`config.yml`
```yml
pimcore_rad_brick:
  ## Define data sources to be used by areabricks
  datasources:
    products_by_category_id:
      service_id: 'coreshop.repository.category' ## Prodive a symfony service
      method: 'findOneById' ## Specify which method to call
      args: 
      - '!q:[category].id' ## Specify which data to pass. The input array is passed by areabricks. the `!q` is required to use `[category].id` as a property path, otherwise the input is seen as a string

  areabricks:
    category_slider:
      label: Category Slider
      editables:
        category:
          type: relation
          options:
            types: ['object']
            subtypes:
              object: ['object']
            classes: ['CoreShopCategory']
      
      datasources: ## Datasource configuration for this areabrick
        products_by_category_id:
          category: 'view[category].element' ## Define category argument (available in input array to the datasource above)
```
The property path of an input argument for a datasource contains following information:
- `request`: Access to the current request object
- `view`: Access to elements in the viewmodel

`edit.html.twig`
```twig
Category: {{ category|raw }}
```
`view.html.twig`
```twig
<div class="slider">
  {% for product in products_by_category_id %}
  <div class="item">{% include 'product-tile.tml.twig' with {product: product} only %}</div>
</div>
```

#### Connecting Editables and datasources

When using datasources, it is also possible to connect editables to items in datasources.
For example product teasers could have a tagline which needs to be added manually,
but all other fields are filled by the product. The following configuration can solve this issue:

```yml
pimcore_rad_brick:
  datasources:
    products_by_category:
      service_id: 'coreshop.repository.category'
      method: 'findOneById'
      args: 
      - '[category].id' ## Specify which data to pass. The input array is passed by areabricks.   
  areabricks:
    category_slider:
      label: Category Slider
      use_edit: true
      editables:
        category:
          type: relation
          options:
            types: ['object']
            subtypes:
              object: ['object']
            classes: ['CoreShopCategory']
        tagline:
          type: input
          datasource:
            products_by_category: id # Provide the property with which the editable can be identified. in this case the editable id will be `tagline` appended to it `_` with the value of the id property of each item coming from the datasource  
      datasources:
        products_by_category:
          category: '!q:[view][category].element'
```
